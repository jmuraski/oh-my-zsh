{"mode":"editor","version":1,"windowDimensions":{"x":104,"y":159,"width":1555,"height":968,"maximized":false},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/jmuraski/Documents/workspace/zeo_ui","buffers":[{"text":"# Android Build Process\n___\n\n## Generate Java Keystore to use for signing the APK\nThis is for reference only, the jks file has been generated and committed to github under zeo_ui.\n\n```\nkeytool -keystore devjam.jks -genkey -alias tcf\n```\n\n###example:\n\n\tEnter keystore password:\n\tRe-enter new password:\n\tWhat is your first and last name?\n  \t\t[Unknown]: <enter>\n\tWhat is the name of your organizational unit?\n  \t\t[Unknown]: devjam\n\tWhat is the name of your organization?\n  \t\t[Unknown]:  devjam\n\tWhat is the name of your City or Locality?\n  \t\t[Unknown]:  minneapolis\n\tWhat is the name of your State or Province?\n  \t\t[Unknown]:  mn\n\tWhat is the two-letter country code for this unit?\n  \t\t[Unknown]:  us\n\tIs CN=Unknown, OU=devjam, O=devjam, L=minneapolis, ST=mn, C=us correct?\n\t\t[no]:  yes\n\n\tEnter key password for <tcf>\n\t\t(RETURN if same as keystore password): <enter>\n\n## Local: Unsigned Android Simulator Deployment\n```\ngrunt buildLocalAndroid\n```\n\n## Alpha: Develop Branch, Signed Android HockeyApp Deployment\n```\ngrunt buildDevelopAndroid\n```\n\nWhen prompted to enter key store information, enter the location of `devjam.jks` you created earlier and the `tcf` alias\n\n\t[?] Enter location of your key store (\"*.jks\"): <absolute path to>/zeo_ui/devjam.jks\n\t[?] Enter key store alias: tcf\n\nBefore the build completes you'll be prompted to enter the password: tcfdevjam\n\nOnce the build completes you can deploy the APK file, located `./platforms/android/ant-build/ZeoAlpha-release.apk`, to your local simulator or upload to [HockeyApp alpha project](https://rink.hockeyapp.net/manage/apps/71045)\n\n## Beta: Master Branch, Signed Android HockeyApp Deployment\n```\ngrunt buildMasterAndroid\n```\n\nWhen prompted to enter key store information, enter the location of `devjam.jks` you created earlier and the `tcf` alias\n\n\t[?] Enter location of your key store (\"*.jks\"): <absolute path to>/zeo_ui/devjam.jks\n\t[?] Enter key store alias: tcf\n\nBefore the build completes you'll be prompted to enter the password: tcfdevjam\n\nOnce the build completes you can deploy the APK file, located `./platforms/android/ant-build/ZeoBeta-release.apk`, to your local simulator or upload to [HockeyApp beta project](https://rink.hockeyapp.net/manage/apps/73638)","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":7},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/android_release.md","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a9461199534b47c77fa59f38a914dc370e369fdb","deserializer":"TextBuffer"},{"text":"# HTML Build Process\n___\n\n## Local HTML\n```\ngrunt buildLocalHtml\ngrunt serve\n```\n\n## Dev / Jenkins HTML\n```\ngrunt jenkinsBuild\ngrunt serve\n```\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":11},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/html_release.md","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"8971b95122d7af376f521e893e65bc07983208d7","deserializer":"TextBuffer"},{"text":"# Follow up Items for Prototype\n\n- [ ] Override Ionic default styling, this will mean moving the ionic styles from the bower dir into our styles directory\n- [ ] State Transition Animation, currently states only slide, we should figure out how we can modify these\n- [ ] Drag and drop off bottom of screen\n- [ ] Change tap trasition from flip to rotate up\n- [ ] move hard coded templates into partials\n- [ ] animate elements for the dragon drop, both box that pops up and state transition\n- [ ] Play around with color schemes\n- [ ] Spinners\n- [ ] Pinch Close for transactions page\n- [ ] Left and right swipes for transactions page\n- [ ] Bill Pay and transfer screens\n- [ ] Disable actions if inappropriate\n- [ ] reset tiles when actions taken on other tiles\n- [ ] enable button on action panes\n- [ ] remote deposit capture button\n- [ ] drag to remote deposit capture\n- [ ] disable transition on dragon drop if same account\n- [ ] disable orientation change\n- [ ] make tiles bigger 4 per page\n- [ ] work on pinch animation, not smooth on phones\n- [ ] Change accounts on bill pay and transfer screens","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":15},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/prototype_todo.md","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"9b551f47b4a3894d15a9cc2e21278b8b83bc932d","deserializer":"TextBuffer"},{"text":"# Zeo Security\n## Table of Contents\n* [Overview](#overview)\n* [Initial Login Flows](#initial)\n\t* [Standard Login](#initial_standard)\n\t* [Login with Remember Me](#initial_remember)\n* [Return Login Flows](#return)\n\t* [Using Refresh Token](#return_refresh)\n\t* [Up Permissions](#return_up)\n* [Log Out Flows](#logout)\n\t* [No Remember Me](#logout_standard)\n\t* [With Remember Me](#logout_remember)\n\t* [Remove Device from Profile](#logout_remove_profile)\n*[Appendix](#appendix)\n\t* [Appendix A - Device Fingerprinting](#appendix_finger)\n\t* [Appendix B - Multi Factor Authentication](#appendix_multi)\n\t* [Appendix C - Endpoint Attack Countermeasures](#appendix_counter)\n\t\t* [Rate Limits](#appendix_counter_rate)\n\t\t* [Captcha](#appendix_counter_captcha)\n\t\t* [Challenge Questions](#appendix_counter_challenge)\n\t* [Appendix D - Permission Levels](#appendix_permissions)\n\t* [Appendix E - Ping Federate](#appendix_pingfederate)\n\n<!--BREAK-->\n## <a name=\"overview\">Overview</a>\nZeo is a mobile application that will be used by customers to: \n* View their GPR (General Purpose Reloadable) card balances\n* View GPR card Transaction lists\n* Add Cards to their account\n* Add funds to their card\nSince this is a mobile application usability is important, but this needs to be balanced with security. Balancing usability and security are always a challenge and both have been taken very seriously for this application. This application will have different tiers of secuirty. The application will allow a user to quickly grant access to the device again, or to enter their credentials for greater access.\n\n![](Security_Diagrams/HighLevel.png)\n\n<!--BREAK-->\n## <a name=\"initial\">Initial Login Flows</a>\n### <a name=\"initial_standard\">Standard Login</a>\nThe standard login is for when the user first comes to the application to login or they returned to the application but chose not to have it remember them. This flow will use basic authentication for flow. There is also some optional alternatives in order to enhance security when it is needed.\n\n![](Security_Diagrams/StandardLogin.png)\n\n1. User opens application and is presented with Login Screen\n2. Login screen is presented to user and is returned a nonce\n3. User enters user name and password\n4. Application submits the user name and password base 64 encoded using basic authentication, a signature is generated using the Nonce and SHA-256 \n5. Server recieves the data and it verifies signature.\n6. Server sends user name and password to LDAP for verification\n7. Server generates access token\n8. Server places access token and permission level and user id in distributed cache\n9. Access token and permission levels returned to application\n10. Access Token submitted on subsequent requests\n\nThis application flow provides certain elements. By using the nonce, it would defeat people hitting the REST endpoints trying to utilize a brute force attack. There are other things that can be utilized also, but this is one of the first steps. The access token is similar to a session id, this access token will have a 60 minute Time To Live (TTL) but it will be supplemented with a 10 minute Time to Idle (TTI). Using a combined approach it will allow the user to stay logged in longer but also means tha the use has to be active to maintain this state. The LDAP server used in this scenario is assumed. This may need to be swapped out for an alternative password store. \n\n### <a name=\"initial_remember\">Login with Remember Me</a>\nIt is believed that since this application is being used on a mobile device, that this device could act as a factor in authentication. The device could be the \"What you Have\" element. This is where Remember Me comes in to play. We want users to be able to open the application on their device and be able to easily get to information that they may want. If the user needs to perform a more sensitive operation (a list of these permissions are in the [Appendix D - Permission Levels](#appendix_permission) , they would need to get additonal permissions, but entering their user name and password (Second Factor). Again the application is trying to balance security and usability. Since not all customers may be comfortable with the application maintaining this lower level of authentication for them, it is an option that the user must choose. This flow describes the Login procedure for the user and the data exchanged to make it so a user can log in at a later time with the \"Remember Me\" function, this flow is covered later in [Using a Refresh Token](#return_refresh).\n\n![](Security_Diagrams/RememberMe.png)\n\n1. User opens application and is presented with Login Screen\n2. Login screen is presented to user and is returned a nonce\n3. User enters user name and password and selects the \"Remember Me\" checkbox\n4. Application submits the user name and password base 64 encoded using basic authentication, a signature is generated using the Nonce and SHA-256 \n5. Server recieves the data and it verifies signature.\n6. Server sends user name and password to LDAP for verification\n7. Server generates access token\n8. Server places access token and permission level and user id in distributed cache\n9. Server Creates refresh token, device Id, and Device Name\n10. Server stores refresh token, device Id, device name, and user name in long term storage (Database)\n11. Server returns access token, permissions, device id, device name, and refresh token to application\n12. Application stores user name, refresh token, device id, and device name in local storage \n13. Access Token submitted on subsequent requests\n\nThis flow is almost identical to the standard login except for the additional data. This data is needed for when the user comes back to be logged in. The device id is used as a shared secret between the device and the server. This value should never be transmitted in the clear other then during this intial transmission.\n\n### Access Token Expires\nWhen a request is made with an expired access token the server will return a status code of 401.  The error message will be the standard error format but will have an error code of expired_token and the description will state that the token is expired. Invalid access tokens will receive a 401 but with a error code of invalid_token. \n\n<!--BREAK-->\n\n## <a name=\"return\">Return Login Flows</a>\nThe return login flows are for a user that chooses the remember me function and then opens the application.  This feature is meant to give the user easy access to items that do not need a high level of secuirty.\n\n### <a name=\"return_refresh\">Using Refresh Token</a>\nAt this point the user decided that the application could remember them and is opening the application again. \n\n![](Security_Diagrams/SecondaryAuth.png)\n\n1. The application presents the user a screen asking if they are the user\n2. User says yes\n3. Application retreives Refresh Token, Device Id, Device Name, and User Name from local storage\n4. Application submits a post request to the Token endpoint with the User Name, Device Name, Refresh Token and a SHA-256 signature with the device id\n5. Server receives request and retrieves data from the database using the user name and device name\n6. Server verifies the signature \n7. Server create access token, and a new refresh token.\n8. Server stores new refresh token in DB and access token and permission in cache\n9. Server sends the access token, refresh token, and permissions to the application\n10. Client saves new refresh token into local storage\n11. Access Token is submitted on subsequent requests\n\n#### Refresh Token with invalid signature\nIf the refresh token is submitted and the signature is invalid, the refresh token will be deleted from the server and can not be used again. The device will recieve a 401 status code, with an error code of invalid_signature. The application will need to remove the refresh token from storage and force full authentication by the user. If the user tries to use a invalid refresh token but the rest of the information is correct the user will get a 401 status code and an error code invalid_token.\n\n### <a name=\"return_up\">Enhancing Permissions</a>\nWhen the user tries to do something that they do not currently have permssions to do, such as edit their profile, the user will be prompted with a user name a password screen.\n1. User is presented with a login screen to enhance permissions, user name should be populated\n2. User enters password\n3. Application encrypts user name and password using the device id as a key\n4. Application posts data to server along with user name and device name\n5. Server looks up the device id using the device name and user name\n6. Server uses device id to decrypt user name and password \n7. Server submits credentials to LDAP for verification\n8. Server creates new access token, with enhaced permissions\n9. Server stores new permission and access token in cache\n10. Server respods with new access token and permissions\n11. Application uses new access token on all subsequent requests.\nThis authentication flow allows for a user to increase their permissions in the application. One of the key elements in this flow is not using Basic Authentication. To help improve security and prevent the credentials being sent in in the clear, this was modified to have them sent encrypted. This way not only are they not clear text, but with the Device Id being used as the key, only this specific device could of sent them.\n\n<!--BREAK-->\n\n## <a name=\"logout\">Log Out Flows</a>\n\n### <a name=\"logout_standard\">Standard Log Out</a>\nThe user is given the option to log out from the application. When this happens it is not enough to ensure that the application removes the access token from its memory, it will also need to send a request to the server to have the access token deleted.\n\n### <a name=\"logout_remember\">Log Out for Remember Me</a>\nWhen a user logs out and they have choosen for the application to remember them, there are more steps involved. The user should be prompted to verify that they want to application to \"Forget Them\" and if they agree the following things should happen:\n1. Access Token is removed from memory\n2. Refresh Token is removed from local storage\n3. Device Id is removed from local storage\n4. User name is removed from local storage\n5. Device Name is removed from local storage\n6 Request made to server to remove Access Token from cache and Refresh Token, User name, Device Id, and Device Name from DB\n\n### <a name=\"logout_remove_profile\">Remove Device from Profile</a>\nOn the profile page the user will be able to see what devices have access to the application, the devices that have been remembered. If the user enhances permissions they can remove any or all devices.  This will call the server and the server will remove that device along with its device id and refresh token from the DB.\n\n## Security Logging\nAll security issues should be sent to a seperate log file. This file can be examined in an ongoing basis. Issues that should be logged are invalid access tokens, invalid signatures, invalid refresh tokens, invalid user name and passwords. The error types should be logged as well as any data about the connection that can be collected, things like the browser type, the ip address and any other data that can be collected.\n\n<!--BREAK-->\n\n## <a name=\"appendix\">Appendix</a>\n### <a name=\"appendix_finger\">Appendix A</a>\n#### Device Fingerprinting\nIn the flows above the server issued a device id which was used as a shared secret between the device and the server. There are other technologies that could be used where the device id could be a finger print instead of a random generated Id. One of the companies that we looked at provided a hosted solution where they could provide a unique id stored on the device as a cookie as well as a fingerprint that they could generate based on a connection to the device. This unique id would not be transmitted to the server by the application it would be looked up by the server. This Id would be retrieved from the external fingerprinting server and could also be scored. Depending on the score, the server could allow access, request further credentials from the client or reject the connection all together. The company we looked at, [ThreatMetrix](http://www.threatmetrix.com) provided these services and allowed for a web based solution as well as SDKs for IOS and Android.\n\n### <a name=\"appendix_multi\">Appendix B</a>\n#### Multi Factor Authentication\nMulti Factor authenication is utilizing more the one factor (what you know, what you have, who you are) at a time to authenticate a user. There are several ways that this can be used as well as a couple of things that can be used for secondary factors. One of the primary ways that this application could use this would be to use a secondary factor on sign up. We believe that the phone number should be something that is known by the bank. When a user sets up thier account, they could receive a text to the device that would have a code they would need to enter to use the account. This same code could be used to enhance the \"Remember Me\" feature, the code could be mixed into the device id or added suplementally to the signature. This would enhance security since the code would have never have been sent to the phone over the network. Using the phone, is primarily using the \"What you have\" factor, an alternative to this would be to use the card itself. The user could enter the card number and some of the fields could be mixed into the device id again to be sent in the signature. The last factor \"Who you are\" is becoming a possibility with advances in phones. Currently new iPhones have a fingerprint scanner and androids can use facial recognition. Neither of these are really ready for use, but could be in the near future.\n\n### <a name=\"appendix_counter\">Appendix C</a>\n#### Endpoint Counter Measures\nAuthentication endpoints make good targets for hackers. Therefore things must be done to make the endpoint more difficult to exploit.\n\n##### <a name=\"appendix_counter_rate\">Rate Limits</a>\nRate limits can be put in place to slow an attacker down. Attacks can not be prevented but if it becomes challenging enough the attackers will move on. By monitoring invalid log in attempts by ip address, the system can gradually increase the time it takes to respond to calls. This will progressively get slower and slower, until the maximum delay is reached. As well as throttling the call, other measures could be put in place for apparent attacks. That could be additional data required in the login, scrambling field names or requiring a nonce.\n\n#### <a name=\"appendix_counter_captcha\">Captcha</a>\nWhen the system seems like it is under an attack it could require a captcha image for login. The server would notify the client that this was required and also give the url for the image. The client would be forced to respond with the captcha as well as the authentication.\n\n#### <a name=\"appendix_counter_challenge\">Challenge Questions</a>\nIn certain situations, if the requests appear to be fraudulent or a higher risk, an additonal challenge question could be asked. The bank would need to have these on file and these challenge questions could be rotated through. Higher risk could be that the device in a different geo location, the device is knknown, or any other thing that triggers a lower then acceptable score for fraud.\n\n### <a name=\"appendix_permissions\">Appendix D</a>\n####Permission Levels\nThere are currently three levels of security for the application. Unauthenticated, Authenticated read only, Authenticated Read/Write.\n##### Unauthenticated\nThis is when a user opens the application for the first time or comes back and is not logged in.\n##### Authenticated Read Only\nWhen the user is authenticated with a refresh token they are in a read only state. They will be able to view their profile (Masked Data), View their account balance, view their transaction list and deposit funds.\n##### Authenticated Read/Write\nRead/Write permissions is when they are fully logged in. This is when they entered their user name and password from teh beggining or if they were presented with the additional authentication screen when they are verified by refresh token. With this additional permissions the user will be able to edit their profile, add an account, remove an account, transfer money off of the card\n\n### <a name=\"appendix_pingfederate\">Appendix E</a>\n#### Ping Federated\nPingIdentity is a company that TCF is using for their commercial single sign on capbility. Some of the capabilities of this tool could potentiall be leveraged for this project. One of these capabilities is API security. Ping Federated is a tool set from ping identitiy that can be used to secure the API.  Further research would be needed to verify if Ping Federated could be easily integrated, would they put any limitations on other security measures.  There are other tools that may prove to be more usable also. Other tools could be Mashery and Appigee. Both of these tools provide cloud based solutions that could be leveraged, but would also need to be evaluated for price and for limitations they put on the overall solution.\t","markers":{"markers":{"1":{"id":1,"range":[[26,25],[26,25]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":20,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/zeo_security.md","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"e2b617e0be9a77f936a5607eabd66ab4deb5cbb5","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"children":[{"id":3,"items":[{"id":7,"softTabs":false,"displayBuffer":{"id":8,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/android_release.md","tabLength":2,"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":11,"softTabs":true,"displayBuffer":{"id":12,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/html_release.md","tabLength":2,"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":15,"softTabs":true,"displayBuffer":{"id":16,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/prototype_todo.md","tabLength":2,"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":20,"softTabs":false,"displayBuffer":{"id":21,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/zeo_security.md","tabLength":2,"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemUri":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/zeo_security.md","focused":true,"deserializer":"Pane"},{"id":19,"items":[{"deserializer":"MarkdownPreviewView","filePath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/prototype_todo.md","editorId":"15"},{"deserializer":"MarkdownPreviewView","filePath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/zeo_security.md","editorId":"20"}],"activeItemUri":"markdown-preview://editor/15","focused":false,"deserializer":"Pane"}],"orientation":"horizontal","deserializer":"PaneAxis"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-gfm","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/jmuraski/Documents/workspace/zeo_ui/docs/android_release.md":1413318501755,"/Users/jmuraski/Documents/workspace/zeo_ui/docs/html_release.md":1413318503287,"/Users/jmuraski/Documents/workspace/zeo_ui/docs/prototype_todo.md":1413318504869,"/Users/jmuraski/Documents/workspace/zeo_ui/docs/zeo_security.md":1413318511515},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":1192498},"tree-view":{"directoryExpansionStates":{"docs":{}},"selectedPath":"/Users/jmuraski/Documents/workspace/zeo_ui/docs/zeo_security.md","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}