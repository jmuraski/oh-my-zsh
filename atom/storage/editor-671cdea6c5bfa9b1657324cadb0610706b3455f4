{"mode":"editor","version":1,"windowDimensions":{"x":151,"y":83,"width":895,"height":643},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/jmuraski/Documents/workspace/zeo_ui/node_modules/grunt-contrib-connect/tasks","buffers":[{"text":"/*\n * grunt-contrib-connect\n * http://gruntjs.com/\n *\n * Copyright (c) 2013 \"Cowboy\" Ben Alman, contributors\n * Licensed under the MIT license.\n */\n\n'use strict';\n\nmodule.exports = function(grunt) {\n  var path = require('path');\n  var connect = require('connect');\n  var http = require('http');\n  var https = require('https');\n  var injectLiveReload = require('connect-livereload');\n  var open = require('open');\n\n  grunt.registerMultiTask('connect', 'Start a connect web server.', function() {\n    // Merge task-specific options with these defaults.\n    var options = this.options({\n      protocol: 'http',\n      port: 8000,\n      hostname: 'localhost',\n      base: '.',\n      directory: null,\n      keepalive: false,\n      debug: false,\n      livereload: false,\n      open: false,\n      middleware: function(connect, options) {\n        var middlewares = [];\n        var directory = options.directory || options.base[options.base.length - 1];\n        if (!Array.isArray(options.base)) {\n          options.base = [options.base];\n        }\n        options.base.forEach(function(base) {\n          // Serve static files.\n          middlewares.push(connect.static(base));\n        });\n        // Make directory browse-able.\n        middlewares.push(connect.directory(directory));\n        return middlewares;\n      }\n    });\n\n    if (options.protocol !== 'http' && options.protocol !== 'https') {\n      grunt.fatal('protocol option must be \\'http\\' or \\'https\\'');\n    }\n\n    // Connect requires the base path to be absolute.\n    if (Array.isArray(options.base)) {\n      options.base = options.base.map(function(base) {\n        return path.resolve(base);\n      });\n    } else {\n      options.base = path.resolve(options.base);\n    }\n\n    // Connect will listen to all interfaces if hostname is null.\n    if (options.hostname === '*') {\n      options.hostname = null;\n    }\n\n    // Connect will listen to ephemeral port if asked\n    if (options.port === '?') {\n      options.port = 0;\n    }\n\n    var middleware = options.middleware ? options.middleware.call(this, connect, options) : [];\n\n    // If --debug was specified, enable logging.\n    if (grunt.option('debug') || options.debug === true) {\n      connect.logger.format('grunt', ('[D] server :method :url :status ' +\n        ':res[content-length] - :response-time ms').magenta);\n      middleware.unshift(connect.logger('grunt'));\n    }\n\n    // Inject live reload snippet\n    if (options.livereload !== false) {\n      if (options.livereload === true) {\n        options.livereload = 35729;\n      }\n      middleware.unshift(injectLiveReload({port: options.livereload}));\n    }\n\n    // Start server.\n    var done = this.async();\n    var taskTarget = this.target;\n    var keepAlive = this.flags.keepalive || options.keepalive;\n\n    var app = connect.apply(null, middleware);\n    var server = null;\n\n    if (options.protocol === 'https') {\n      server = https.createServer({\n        key: options.key || grunt.file.read(path.join(__dirname, 'certs', 'server.key')).toString(),\n        cert: options.cert || grunt.file.read(path.join(__dirname, 'certs', 'server.crt')).toString(),\n        ca: options.ca || grunt.file.read(path.join(__dirname, 'certs', 'ca.crt')).toString(),\n        passphrase: options.passphrase || 'grunt',\n      }, app);\n    } else {\n      server = http.createServer(app);\n    }\n\n    server\n      .listen(options.port, options.hostname)\n      .on('listening', function() {\n        var address = server.address();\n        grunt.log.writeln('Started connect web server on ' + (address.address || 'localhost') + ':' + address.port + '.');\n        grunt.config.set('connect.' + taskTarget + '.options.hostname', address.address || 'localhost');\n        grunt.config.set('connect.' + taskTarget + '.options.port', address.port);\n\n        grunt.event.emit('connect.' + taskTarget + '.listening', (address.address || 'localhost'), address.port);\n\n        if (options.open === true) {\n          open(options.protocol + '://' + address.address + ':' + address.port);\n        } else if (typeof options.open === 'string') {\n          open(options.open);\n        }\n\n        if (!keepAlive) {\n          done();\n        }\n      })\n      .on('error', function(err) {\n        if (err.code === 'EADDRINUSE') {\n          grunt.fatal('Port ' + options.port + ' is already in use by another process.');\n        } else {\n          grunt.fatal(err);\n        }\n      });\n\n    // So many people expect this task to keep alive that I'm adding an option\n    // for it. Running the task explicitly as grunt:keepalive will override any\n    // value stored in the config. Have fun, people.\n    if (keepAlive) {\n      // This is now an async task. Since we don't call the \"done\"\n      // function, this task will never, ever, ever terminate. Have fun!\n      grunt.log.write('Waiting forever...\\n');\n    }\n  });\n};\n","markers":{"markers":{"1":{"id":1,"range":[[15,6],[15,22]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":11,"autoscroll":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/jmuraski/Documents/workspace/zeo_ui/node_modules/grunt-contrib-connect/tasks/connect.js","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"0c9022309549560b38eb41b3bbfc12d4b4c80c27","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":7,"items":[{"id":11,"softTabs":true,"displayBuffer":{"id":12,"softWrap":false,"editorWidthInChars":null,"scrollTop":234,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/jmuraski/Documents/workspace/zeo_ui/node_modules/grunt-contrib-connect/tasks/connect.js","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/jmuraski/Documents/workspace/zeo_ui/node_modules/grunt-contrib-connect/tasks/connect.js","focused":false,"deserializer":"Pane"},"activePaneId":7,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-javascript"],"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":{"findHistory":["middle","injectLiveReload"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}}},"fuzzy-finder":{"/Users/jmuraski/Documents/workspace/zeo_ui/node_modules/grunt-contrib-connect/tasks/connect.js":1410202138900},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":9936730},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/jmuraski/Documents/workspace/zeo_ui/node_modules/grunt-contrib-connect/tasks/connect.js","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}